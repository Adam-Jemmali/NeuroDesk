-- ============================================
-- NEXUS Execution Mode Database Schema
-- ============================================
-- Run this SQL in your Supabase SQL Editor
-- ============================================

-- Nexus execution runs (top-level container)
CREATE TABLE IF NOT EXISTS public.nexus_runs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  mode TEXT NOT NULL DEFAULT 'execution', -- 'simulation' or 'execution'
  user_message TEXT NOT NULL,
  status TEXT NOT NULL DEFAULT 'pending', -- 'pending', 'planning', 'approved', 'executing', 'completed', 'failed', 'rejected'
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  completed_at TIMESTAMPTZ,
  error_message TEXT
);

-- Task plans generated by Planner agent
CREATE TABLE IF NOT EXISTS public.task_plans (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  run_id UUID NOT NULL REFERENCES public.nexus_runs(id) ON DELETE CASCADE,
  plan_json JSONB NOT NULL, -- Structured plan with steps, costs, risks
  estimated_cost DECIMAL(10, 2) DEFAULT 0,
  risk_level TEXT NOT NULL DEFAULT 'low', -- 'low', 'medium', 'high'
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Individual task steps within a plan
CREATE TABLE IF NOT EXISTS public.task_steps (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  plan_id UUID NOT NULL REFERENCES public.task_plans(id) ON DELETE CASCADE,
  step_number INTEGER NOT NULL,
  action_type TEXT NOT NULL, -- 'api_call', 'data_update', 'payment', 'notification', etc.
  description TEXT NOT NULL,
  parameters JSONB, -- Step-specific parameters
  estimated_cost DECIMAL(10, 2) DEFAULT 0, -- Cost estimate for this step
  requires_approval BOOLEAN NOT NULL DEFAULT false, -- Computed at plan time
  risk_level TEXT NOT NULL DEFAULT 'low', -- 'low', 'medium', 'high' (step-level)
  side_effect TEXT NOT NULL DEFAULT 'read_only', -- 'read_only', 'external_write', 'payment', 'physical', 'destructive'
  status TEXT NOT NULL DEFAULT 'pending', -- 'pending', 'approved', 'executing', 'completed', 'failed', 'skipped'
  result JSONB, -- Execution result
  executed_at TIMESTAMPTZ,
  error_message TEXT,
  UNIQUE(plan_id, step_number)
);

-- Approval queue for high-stakes actions
CREATE TABLE IF NOT EXISTS public.approvals (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  run_id UUID NOT NULL REFERENCES public.nexus_runs(id) ON DELETE CASCADE,
  step_id UUID REFERENCES public.task_steps(id) ON DELETE CASCADE, -- NULL if approving entire plan
  approval_type TEXT NOT NULL, -- 'plan' or 'step'
  reason TEXT NOT NULL, -- Why approval is needed
  status TEXT NOT NULL DEFAULT 'pending', -- 'pending', 'approved', 'rejected', 'expired'
  requested_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  reviewed_at TIMESTAMPTZ,
  reviewed_by UUID REFERENCES auth.users(id), -- Can be different user if multi-user approval
  review_notes TEXT,
  expires_at TIMESTAMPTZ -- Optional expiration
);

-- Comprehensive audit log
CREATE TABLE IF NOT EXISTS public.audit_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  run_id UUID REFERENCES public.nexus_runs(id) ON DELETE SET NULL,
  step_id UUID REFERENCES public.task_steps(id) ON DELETE SET NULL,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  event_type TEXT NOT NULL, -- 'run_created', 'plan_generated', 'step_executed', 'approval_requested', 'approval_granted', etc.
  agent_role TEXT, -- 'planner', 'executor', 'verifier', 'user'
  message TEXT NOT NULL,
  metadata JSONB, -- Additional context
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Enable RLS on all tables
ALTER TABLE public.nexus_runs ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.task_plans ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.task_steps ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.approvals ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

-- RLS Policies (users can only see their own data)
-- All policies tie access to nexus_runs.user_id via proper joins

CREATE POLICY "Users can manage their own nexus_runs"
  ON public.nexus_runs FOR ALL
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- task_plans: Join through run_id -> nexus_runs.user_id
CREATE POLICY "Users can view their own task_plans"
  ON public.task_plans FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM public.nexus_runs
      WHERE nexus_runs.id = task_plans.run_id
      AND nexus_runs.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can insert their own task_plans"
  ON public.task_plans FOR INSERT
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM public.nexus_runs
      WHERE nexus_runs.id = task_plans.run_id
      AND nexus_runs.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can update their own task_plans"
  ON public.task_plans FOR UPDATE
  USING (
    EXISTS (
      SELECT 1 FROM public.nexus_runs
      WHERE nexus_runs.id = task_plans.run_id
      AND nexus_runs.user_id = auth.uid()
    )
  );

-- task_steps: Join through plan_id -> task_plans.run_id -> nexus_runs.user_id
CREATE POLICY "Users can view their own task_steps"
  ON public.task_steps FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM public.task_plans
      INNER JOIN public.nexus_runs ON nexus_runs.id = task_plans.run_id
      WHERE task_plans.id = task_steps.plan_id
      AND nexus_runs.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can insert their own task_steps"
  ON public.task_steps FOR INSERT
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM public.task_plans
      INNER JOIN public.nexus_runs ON nexus_runs.id = task_plans.run_id
      WHERE task_plans.id = task_steps.plan_id
      AND nexus_runs.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can update their own task_steps"
  ON public.task_steps FOR UPDATE
  USING (
    EXISTS (
      SELECT 1 FROM public.task_plans
      INNER JOIN public.nexus_runs ON nexus_runs.id = task_plans.run_id
      WHERE task_plans.id = task_steps.plan_id
      AND nexus_runs.user_id = auth.uid()
    )
  );

-- approvals: Join through run_id -> nexus_runs.user_id
CREATE POLICY "Users can manage their own approvals"
  ON public.approvals FOR ALL
  USING (
    EXISTS (
      SELECT 1 FROM public.nexus_runs
      WHERE nexus_runs.id = approvals.run_id
      AND nexus_runs.user_id = auth.uid()
    )
  )
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM public.nexus_runs
      WHERE nexus_runs.id = approvals.run_id
      AND nexus_runs.user_id = auth.uid()
    )
  );

-- audit_logs: Direct user_id check, or derive via run_id
CREATE POLICY "Users can view their own audit_logs"
  ON public.audit_logs FOR SELECT
  USING (
    auth.uid() = audit_logs.user_id
    OR EXISTS (
      SELECT 1 FROM public.nexus_runs
      WHERE nexus_runs.id = audit_logs.run_id
      AND nexus_runs.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can insert their own audit_logs"
  ON public.audit_logs FOR INSERT
  WITH CHECK (auth.uid() = audit_logs.user_id);

-- Indexes for performance
CREATE INDEX idx_nexus_runs_user_id ON public.nexus_runs(user_id);
CREATE INDEX idx_nexus_runs_status ON public.nexus_runs(status);
CREATE INDEX idx_task_plans_run_id ON public.task_plans(run_id);
CREATE INDEX idx_task_steps_plan_id ON public.task_steps(plan_id);
CREATE INDEX idx_task_steps_status ON public.task_steps(status);
CREATE INDEX idx_approvals_status ON public.approvals(status);
CREATE INDEX idx_approvals_run_id ON public.approvals(run_id);
CREATE INDEX idx_audit_logs_run_id ON public.audit_logs(run_id);
CREATE INDEX idx_audit_logs_user_id ON public.audit_logs(user_id);
CREATE INDEX idx_audit_logs_created_at ON public.audit_logs(created_at DESC);
